#!/usr/bin/env python3
"""
vulnerability_system.py

Advanced vulnerability analysis system that:
1. Scans repository manifests for dependencies
2. Fetches vulnerability data from NVD and GitHub APIs
3. Builds a Neo4j graph of vulnerabilities and their impact
4. Provides remediation recommendations
"""

import os
import argparse
import json
import logging
import tempfile
import subprocess
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import requests
from neo4j import GraphDatabase
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Data class for vulnerability information."""
    cve_id: str
    severity: str
    description: str
    cvss_score: Optional[float]
    published_date: str
    affected_versions: List[str]
    fixed_versions: List[str]

@dataclass
class Package:
    """Data class for package information."""
    name: str
    version: str
    ecosystem: str  # 'python', 'javascript', 'npm', etc.

class VulnerabilityAnalyzer:
    """Main class for vulnerability analysis."""
    
    def __init__(self):
        self.neo4j_driver = None
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.github_api_base = "https://api.github.com"
        
    def connect_neo4j(self) -> bool:
        """Connect to Neo4j database."""
        try:
            uri = os.getenv("NEO4J_URI")
            username = os.getenv("NEO4J_USERNAME")
            password = os.getenv("NEO4J_PASSWORD")
            
            if not all([uri, username, password]):
                logger.error("Missing Neo4j environment variables")
                return False
                
            self.neo4j_driver = GraphDatabase.driver(uri, auth=(username, password))
            # Test connection
            with self.neo4j_driver.session() as session:
                session.run("RETURN 1")
            logger.info("Successfully connected to Neo4j")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to Neo4j: {e}")
            return False

    def load_manifests(self, repo_dir: str) -> List[Package]:
        """Parse requirements.txt, package.json, and other manifest files."""
        packages = []
        repo_path = Path(repo_dir)
        
        # Python requirements.txt
        requirements_file = repo_path / "requirements.txt"
        if requirements_file.exists():
            packages.extend(self._parse_requirements_txt(requirements_file))
        
        # Node.js package.json
        package_json = repo_path / "package.json"
        if package_json.exists():
            packages.extend(self._parse_package_json(package_json))
        
        # Python setup.py
        setup_py = repo_path / "setup.py"
        if setup_py.exists():
            packages.extend(self._parse_setup_py(setup_py))
        
        # Poetry pyproject.toml
        pyproject_toml = repo_path / "pyproject.toml"
        if pyproject_toml.exists():
            packages.extend(self._parse_pyproject_toml(pyproject_toml))
        
        logger.info(f"Found {len(packages)} packages in manifests")
        return packages

    def _parse_requirements_txt(self, file_path: Path) -> List[Package]:
        """Parse Python requirements.txt file."""
        packages = []
        try:
            with open(file_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Handle different formats: package==version, package>=version, etc.
                        if '==' in line:
                            name, version = line.split('==', 1)
                        elif '>=' in line:
                            name, version = line.split('>=', 1)
                        elif '<=' in line:
                            name, version = line.split('<=', 1)
                        else:
                            name, version = line, "latest"
                        
                        packages.append(Package(
                            name=name.strip(),
                            version=version.strip(),
                            ecosystem="python"
                        ))
        except Exception as e:
            logger.error(f"Error parsing requirements.txt: {e}")
        return packages

    def _parse_package_json(self, file_path: Path) -> List[Package]:
        """Parse Node.js package.json file."""
        packages = []
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
                
            # Dependencies
            for dep_type in ['dependencies', 'devDependencies', 'peerDependencies']:
                if dep_type in data:
                    for name, version in data[dep_type].items():
                        packages.append(Package(
                            name=name,
                            version=str(version),
                            ecosystem="javascript"
                        ))
        except Exception as e:
            logger.error(f"Error parsing package.json: {e}")
        return packages

    def _parse_setup_py(self, file_path: Path) -> List[Package]:
        """Parse Python setup.py file."""
        packages = []
        try:
            # Simple regex-based parsing for common patterns
            content = file_path.read_text()
            import re
            
            # Look for install_requires
            install_requires_match = re.search(r'install_requires\s*=\s*\[(.*?)\]', content, re.DOTALL)
            if install_requires_match:
                requires_text = install_requires_match.group(1)
                for line in requires_text.split('\n'):
                    line = line.strip().strip('"\'')
                    if line and not line.startswith('#'):
                        if '==' in line:
                            name, version = line.split('==', 1)
                            packages.append(Package(
                                name=name.strip(),
                                version=version.strip(),
                                ecosystem="python"
                            ))
        except Exception as e:
            logger.error(f"Error parsing setup.py: {e}")
        return packages

    def _parse_pyproject_toml(self, file_path: Path) -> List[Package]:
        """Parse Poetry pyproject.toml file."""
        packages = []
        try:
            content = file_path.read_text()
            import re
            
            # Look for dependencies section
            dependencies_match = re.search(r'\[tool\.poetry\.dependencies\](.*?)(?=\[|$)', content, re.DOTALL)
            if dependencies_match:
                deps_text = dependencies_match.group(1)
                for line in deps_text.split('\n'):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '=' in line:
                            name, version = line.split('=', 1)
                            packages.append(Package(
                                name=name.strip(),
                                version=version.strip().strip('"'),
                                ecosystem="python"
                            ))
        except Exception as e:
            logger.error(f"Error parsing pyproject.toml: {e}")
        return packages

    def fetch_vulnerabilities_for(self, pkg: Package) -> List[Vulnerability]:
        """Fetch vulnerabilities for a package from NVD and GitHub APIs."""
        vulnerabilities = []
        
        # Try NVD API first
        nvd_vulns = self._fetch_from_nvd(pkg)
        vulnerabilities.extend(nvd_vulns)
        
        # Try GitHub Security API
        github_vulns = self._fetch_from_github(pkg)
        vulnerabilities.extend(github_vulns)
        
        logger.info(f"Found {len(vulnerabilities)} vulnerabilities for {pkg.name}@{pkg.version}")
        return vulnerabilities

    def _fetch_from_nvd(self, pkg: Package) -> List[Vulnerability]:
        """Fetch vulnerabilities from NVD API."""
        vulnerabilities = []
        try:
            # Search for vulnerabilities by package name
            params = {
                "keywordSearch": pkg.name,
                "resultsPerPage": 20
            }
            
            response = requests.get(self.nvd_api_base, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            for vuln in data.get('vulnerabilities', []):
                cve = vuln.get('cve', {})
                cve_id = cve.get('id', '')
                
                # Check if this vulnerability affects our package version
                if self._is_version_affected(cve, pkg):
                    metrics = cve.get('metrics', {})
                    cvss_v3 = metrics.get('cvssMetricV31', [{}])[0] if metrics.get('cvssMetricV31') else metrics.get('cvssMetricV30', [{}])[0]
                    
                    vulnerabilities.append(Vulnerability(
                        cve_id=cve_id,
                        severity=cvss_v3.get('cvssData', {}).get('baseSeverity', 'UNKNOWN'),
                        description=cve.get('descriptions', [{}])[0].get('value', 'No description available'),
                        cvss_score=float(cvss_v3.get('cvssData', {}).get('baseScore', 0)),
                        published_date=cve.get('published', ''),
                        affected_versions=self._extract_affected_versions(cve, pkg),
                        fixed_versions=self._extract_fixed_versions(cve, pkg)
                    ))
                    
        except Exception as e:
            logger.error(f"Error fetching from NVD for {pkg.name}: {e}")
        
        return vulnerabilities

    def _fetch_from_github(self, pkg: Package) -> List[Vulnerability]:
        """Fetch vulnerabilities from GitHub Security API."""
        vulnerabilities = []
        try:
            # GitHub Security API requires authentication
            github_token = os.getenv("GITHUB_TOKEN")
            headers = {}
            if github_token:
                headers["Authorization"] = f"token {github_token}"
            
            # Search for security advisories
            search_url = f"{self.github_api_base}/search/repositories"
            params = {
                "q": f"{pkg.name} vulnerability",
                "sort": "updated",
                "order": "desc"
            }
            
            response = requests.get(search_url, headers=headers, params=params, timeout=10)
            response.raise_for_status()
            
            # Note: GitHub's security API is limited, so we focus on NVD for now
            logger.info(f"GitHub search completed for {pkg.name}")
            
        except Exception as e:
            logger.error(f"Error fetching from GitHub for {pkg.name}: {e}")
        
        return vulnerabilities

    def _is_version_affected(self, cve: Dict, pkg: Package) -> bool:
        """Check if the package version is affected by the vulnerability."""
        try:
            configurations = cve.get('configurations', [])
            for config in configurations:
                nodes = config.get('nodes', [])
                for node in nodes:
                    cpe_match = node.get('cpeMatch', [])
                    for match in cpe_match:
                        cpe = match.get('criteria', '')
                        if pkg.name.lower() in cpe.lower():
                            # Simple version check - in production, use proper version comparison
                            return True
            return False
        except Exception as e:
            logger.error(f"Error checking version affected: {e}")
            return False

    def _extract_affected_versions(self, cve: Dict, pkg: Package) -> List[str]:
        """Extract affected versions from CVE data."""
        versions = []
        try:
            configurations = cve.get('configurations', [])
            for config in configurations:
                nodes = config.get('nodes', [])
                for node in nodes:
                    cpe_match = node.get('cpeMatch', [])
                    for match in cpe_match:
                        cpe = match.get('criteria', '')
                        if pkg.name.lower() in cpe.lower():
                            # Extract version from CPE
                            if ':' in cpe:
                                version_part = cpe.split(':')[-1]
                                if version_part != '*':
                                    versions.append(version_part)
        except Exception as e:
            logger.error(f"Error extracting affected versions: {e}")
        return versions

    def _extract_fixed_versions(self, cve: Dict, pkg: Package) -> List[str]:
        """Extract fixed versions from CVE data."""
        # This would require parsing the CVE data more carefully
        # For now, return empty list
        return []

    def annotate_graph(self, pkg: Package, vulns: List[Vulnerability]):
        """Annotate Neo4j graph with vulnerability information."""
        if not self.neo4j_driver:
            logger.error("Neo4j driver not connected")
            return
        
        try:
            with self.neo4j_driver.session() as session:
                # Create constraints if they don't exist
                session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (p:Package) REQUIRE p.name IS UNIQUE")
                session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (v:Vulnerability) REQUIRE v.cve_id IS UNIQUE")
                
                # Create Package node
                session.run(
                    "MERGE (p:Package {name: $name, version: $version, ecosystem: $ecosystem})",
                    {"name": pkg.name, "version": pkg.version, "ecosystem": pkg.ecosystem}
                )
                
                # Create Vulnerability nodes and relationships
                for vuln in vulns:
                    session.run(
                        """
                        MERGE (v:Vulnerability {
                            cve_id: $cve_id,
                            severity: $severity,
                            description: $description,
                            cvss_score: $cvss_score,
                            published_date: $published_date
                        })
                        MERGE (p:Package {name: $pkg_name})
                        MERGE (p)-[:AFFECTED_BY]->(v)
                        """,
                        {
                            "cve_id": vuln.cve_id,
                            "severity": vuln.severity,
                            "description": vuln.description,
                            "cvss_score": vuln.cvss_score,
                            "published_date": vuln.published_date,
                            "pkg_name": pkg.name
                        }
                    )
                    
                    # Add affected versions
                    for version in vuln.affected_versions:
                        session.run(
                            """
                            MERGE (v:Vulnerability {cve_id: $cve_id})
                            MERGE (av:AffectedVersion {version: $version})
                            MERGE (v)-[:AFFECTS]->(av)
                            """,
                            {"cve_id": vuln.cve_id, "version": version}
                        )
                
            logger.info(f"Annotated graph with {len(vulns)} vulnerabilities for {pkg.name}")
            
        except Exception as e:
            logger.error(f"Error annotating graph: {e}")

    def traverse_impact(self, cve_id: str) -> List[str]:
        """Find all files/modules that depend on an affected module."""
        if not self.neo4j_driver:
            logger.error("Neo4j driver not connected")
            return []
        
        try:
            with self.neo4j_driver.session() as session:
                # Find all files that import packages affected by this CVE
                result = session.run(
                    """
                    MATCH (f:File)-[:IMPORTS]->(m:Module)-[:AFFECTED_BY]->(v:Vulnerability {cve_id: $cve_id})
                    RETURN DISTINCT f.path as file_path
                    """,
                    {"cve_id": cve_id}
                )
                
                impacted_files = [record["file_path"] for record in result]
                logger.info(f"Found {len(impacted_files)} impacted files for CVE {cve_id}")
                return impacted_files
                
        except Exception as e:
            logger.error(f"Error traversing impact: {e}")
            return []

    def recommend_remediations(self, pkg: Package, vulns: List[Vulnerability]) -> Dict[str, Any]:
        """Generate remediation recommendations."""
        recommendations = {
            "package": pkg.name,
            "current_version": pkg.version,
            "vulnerabilities": len(vulns),
            "actions": [],
            "priority": "LOW"
        }
        
        if not vulns:
            recommendations["actions"].append("No vulnerabilities found - package is secure")
            return recommendations
        
        # Determine priority based on highest CVSS score
        max_cvss = max([v.cvss_score or 0 for v in vulns])
        if max_cvss >= 9.0:
            recommendations["priority"] = "CRITICAL"
        elif max_cvss >= 7.0:
            recommendations["priority"] = "HIGH"
        elif max_cvss >= 4.0:
            recommendations["priority"] = "MEDIUM"
        
        # Generate specific recommendations
        for vuln in vulns:
            if vuln.fixed_versions:
                recommendations["actions"].append(
                    f"Update {pkg.name} to version {vuln.fixed_versions[0]} to fix {vuln.cve_id}"
                )
            else:
                recommendations["actions"].append(
                    f"Investigate {vuln.cve_id} - no fixed version available"
                )
        
        # Add general recommendations
        if recommendations["priority"] in ["CRITICAL", "HIGH"]:
            recommendations["actions"].append("Immediate action required")
        else:
            recommendations["actions"].append("Update when convenient")
        
        return recommendations

    def close(self):
        """Close Neo4j connection."""
        if self.neo4j_driver:
            self.neo4j_driver.close()

def main():
    """Main function."""
    parser = argparse.ArgumentParser(description="Vulnerability analysis system")
    parser.add_argument("--repo", required=True, help="Repository directory to analyze")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose logging")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    analyzer = VulnerabilityAnalyzer()
    
    try:
        # Connect to Neo4j
        if not analyzer.connect_neo4j():
            logger.error("Failed to connect to Neo4j. Exiting.")
            return 1
        
        # Load manifests
        manifests = analyzer.load_manifests(args.repo)
        if not manifests:
            logger.warning("No packages found in repository manifests")
            return 0
        
        # Analyze each package
        total_vulns = 0
        for pkg in manifests:
            logger.info(f"Analyzing {pkg.name}@{pkg.version}")
            
            vulns = analyzer.fetch_vulnerabilities_for(pkg)
            if vulns:
                analyzer.annotate_graph(pkg, vulns)
                
                # Get impact for first vulnerability
                if vulns:
                    impact = analyzer.traverse_impact(vulns[0].cve_id)
                    recs = analyzer.recommend_remediations(pkg, vulns)
                    
                    print(f"\n📦 {pkg.name}@{pkg.version}")
                    print(f"🔴 CVEs: {len(vulns)}")
                    print(f"📁 Impacted files: {len(impact)}")
                    print(f"💡 Priority: {recs['priority']}")
                    print(f"✅ Recommendations:")
                    for action in recs['actions']:
                        print(f"   - {action}")
                    
                    total_vulns += len(vulns)
        
        print(f"\n🎯 Summary: Found {total_vulns} vulnerabilities across {len(manifests)} packages")
        
    except KeyboardInterrupt:
        logger.info("Analysis interrupted by user")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1
    finally:
        analyzer.close()
    
    return 0

if __name__ == "__main__":
    exit(main())