#!/usr/bin/env python3
"""
test_vulnerability_system.py

Comprehensive test suite for the vulnerability analysis system.
Includes happy-path tests and edge-case scenarios.
"""

import pytest
import tempfile
import json
import os
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from vulnerability_system import VulnerabilityAnalyzer, Package, Vulnerability


class TestVulnerabilityAnalyzer:
    """Test class for VulnerabilityAnalyzer."""
    
    @pytest.fixture
    def analyzer(self):
        """Create a VulnerabilityAnalyzer instance for testing."""
        return VulnerabilityAnalyzer()
    
    @pytest.fixture
    def temp_repo(self):
        """Create a temporary repository with test files."""
        with tempfile.TemporaryDirectory() as temp_dir:
            repo_path = Path(temp_dir)
            
            # Create requirements.txt
            requirements_content = """
requests==2.28.1
flask==2.2.3
django==4.1.7
# Comment line
numpy>=1.21.0
            """
            (repo_path / "requirements.txt").write_text(requirements_content)
            
            # Create package.json
            package_json_content = {
                "name": "test-project",
                "version": "1.0.0",
                "dependencies": {
                    "express": "^4.18.2",
                    "lodash": "4.17.21"
                },
                "devDependencies": {
                    "jest": "^29.5.0"
                }
            }
            (repo_path / "package.json").write_text(json.dumps(package_json_content))
            
            # Create setup.py
            setup_py_content = '''
from setuptools import setup, find_packages

setup(
    name="test-package",
    version="1.0.0",
    install_requires=[
        "requests>=2.25.0",
        "pandas==1.5.3"
    ]
)
'''
            (repo_path / "setup.py").write_text(setup_py_content)
            
            yield repo_path

    # ==================== HAPPY PATH TESTS ====================

    def test_connect_neo4j_success(self, analyzer):
        """Test successful Neo4j connection."""
        with patch.dict(os.environ, {
            'NEO4J_URI': 'bolt://localhost:7687',
            'NEO4J_USERNAME': 'neo4j',
            'NEO4J_PASSWORD': 'password'
        }):
            with patch('vulnerability_system.GraphDatabase') as mock_graph_db:
                mock_driver = Mock()
                mock_session = Mock()
                mock_session.run.return_value = None
                mock_driver.session.return_value = Mock()
                mock_driver.session.return_value.__enter__ = Mock(return_value=mock_session)
                mock_driver.session.return_value.__exit__ = Mock(return_value=None)
                mock_graph_db.driver.return_value = mock_driver
                
                result = analyzer.connect_neo4j()
                
                assert result is True
                assert analyzer.neo4j_driver is not None

    def test_load_manifests_python_only(self, analyzer, temp_repo):
        """Test loading manifests with Python packages only."""
        # Create only requirements.txt
        (temp_repo / "package.json").unlink(missing_ok=True)
        (temp_repo / "setup.py").unlink(missing_ok=True)
        
        packages = analyzer.load_manifests(str(temp_repo))
        
        assert len(packages) == 4  # requests, flask, django, numpy
        assert any(pkg.name == "requests" and pkg.version == "2.28.1" for pkg in packages)
        assert any(pkg.name == "flask" and pkg.version == "2.2.3" for pkg in packages)
        assert all(pkg.ecosystem == "python" for pkg in packages)

    def test_load_manifests_javascript_only(self, analyzer, temp_repo):
        """Test loading manifests with JavaScript packages only."""
        # Create only package.json
        (temp_repo / "requirements.txt").unlink(missing_ok=True)
        (temp_repo / "setup.py").unlink(missing_ok=True)
        
        packages = analyzer.load_manifests(str(temp_repo))
        
        assert len(packages) == 3  # express, lodash, jest
        assert any(pkg.name == "express" for pkg in packages)
        assert any(pkg.name == "lodash" for pkg in packages)
        assert any(pkg.name == "jest" for pkg in packages)
        assert all(pkg.ecosystem == "javascript" for pkg in packages)

    def test_fetch_vulnerabilities_success(self, analyzer):
        """Test successful vulnerability fetching."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        
        mock_response = Mock()
        mock_response.json.return_value = {
            "vulnerabilities": [
                {
                    "cve": {
                        "id": "CVE-2023-1234",
                        "descriptions": [{"value": "Test vulnerability"}],
                        "published": "2023-01-01T00:00:00Z",
                        "metrics": {
                            "cvssMetricV31": [{
                                "cvssData": {
                                    "baseSeverity": "HIGH",
                                    "baseScore": 8.5
                                }
                            }]
                        },
                        "configurations": [{
                            "nodes": [{
                                "cpeMatch": [{
                                    "criteria": "cpe:2.3:a:requests:requests:2.28.1:*:*:*:*:*:*:*:*"
                                }]
                            }]
                        }]
                    }
                }
            ]
        }
        mock_response.raise_for_status.return_value = None
        
        with patch('requests.get', return_value=mock_response):
            vulns = analyzer.fetch_vulnerabilities_for(pkg)
            
            assert len(vulns) == 1
            assert vulns[0].cve_id == "CVE-2023-1234"
            assert vulns[0].severity == "HIGH"
            assert vulns[0].cvss_score == 8.5

    def test_annotate_graph_success(self, analyzer):
        """Test successful graph annotation."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        vuln = Vulnerability(
            cve_id="CVE-2023-1234",
            severity="HIGH",
            description="Test vulnerability",
            cvss_score=8.5,
            published_date="2023-01-01T00:00:00Z",
            affected_versions=["2.28.1"],
            fixed_versions=["2.29.0"]
        )
        
        mock_session = Mock()
        mock_driver = Mock()
        mock_driver.session.return_value = Mock()
        mock_driver.session.return_value.__enter__ = Mock(return_value=mock_session)
        mock_driver.session.return_value.__exit__ = Mock(return_value=None)
        
        with patch.object(analyzer, 'neo4j_driver', mock_driver):
            analyzer.annotate_graph(pkg, [vuln])
            
            # Verify session.run was called for constraints and nodes
            assert mock_session.run.call_count >= 3

    def test_recommend_remediations_with_vulnerabilities(self, analyzer):
        """Test remediation recommendations with vulnerabilities."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        vulns = [
            Vulnerability(
                cve_id="CVE-2023-1234",
                severity="HIGH",
                description="Test vulnerability",
                cvss_score=8.5,
                published_date="2023-01-01T00:00:00Z",
                affected_versions=["2.28.1"],
                fixed_versions=["2.29.0"]
            )
        ]
        
        recs = analyzer.recommend_remediations(pkg, vulns)
        
        assert recs["package"] == "requests"
        assert recs["current_version"] == "2.28.1"
        assert recs["vulnerabilities"] == 1
        assert recs["priority"] == "HIGH"
        assert len(recs["actions"]) > 0
        assert any("Update requests to version 2.29.0" in action for action in recs["actions"])

    # ==================== EDGE CASE TESTS ====================

    def test_connect_neo4j_missing_env_vars(self, analyzer):
        """Test Neo4j connection with missing environment variables."""
        with patch.dict(os.environ, {}, clear=True):
            result = analyzer.connect_neo4j()
            
            assert result is False
            assert analyzer.neo4j_driver is None

    def test_connect_neo4j_connection_failure(self, analyzer):
        """Test Neo4j connection failure."""
        with patch.dict(os.environ, {
            'NEO4J_URI': 'bolt://invalid:7687',
            'NEO4J_USERNAME': 'neo4j',
            'NEO4J_PASSWORD': 'password'
        }):
            with patch('vulnerability_system.GraphDatabase') as mock_graph_db:
                mock_graph_db.driver.side_effect = Exception("Connection failed")
                
                result = analyzer.connect_neo4j()
                
                assert result is False
                assert analyzer.neo4j_driver is None

    def test_load_manifests_empty_repo(self, analyzer):
        """Test loading manifests from empty repository."""
        with tempfile.TemporaryDirectory() as temp_dir:
            packages = analyzer.load_manifests(temp_dir)
            
            assert len(packages) == 0

    def test_load_manifests_malformed_files(self, analyzer):
        """Test loading manifests with malformed files."""
        with tempfile.TemporaryDirectory() as temp_dir:
            repo_path = Path(temp_dir)
            
            # Create malformed requirements.txt
            (repo_path / "requirements.txt").write_text("invalid content\n==\n>=")
            
            # Create malformed package.json
            (repo_path / "package.json").write_text('{"invalid": json}')
            
            packages = analyzer.load_manifests(temp_dir)
            
            # Should handle errors gracefully and return some packages (even if malformed)
            assert isinstance(packages, list)

    def test_fetch_vulnerabilities_api_failure(self, analyzer):
        """Test vulnerability fetching when API fails."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        
        with patch('requests.get', side_effect=Exception("API Error")):
            vulns = analyzer.fetch_vulnerabilities_for(pkg)
            
            assert len(vulns) == 0

    def test_fetch_vulnerabilities_empty_response(self, analyzer):
        """Test vulnerability fetching with empty API response."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        
        mock_response = Mock()
        mock_response.json.return_value = {"vulnerabilities": []}
        mock_response.raise_for_status.return_value = None
        
        with patch('requests.get', return_value=mock_response):
            vulns = analyzer.fetch_vulnerabilities_for(pkg)
            
            assert len(vulns) == 0

    def test_annotate_graph_no_driver(self, analyzer):
        """Test graph annotation without Neo4j driver."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        vulns = [Vulnerability(
            cve_id="CVE-2023-1234",
            severity="HIGH",
            description="Test",
            cvss_score=8.5,
            published_date="2023-01-01T00:00:00Z",
            affected_versions=[],
            fixed_versions=[]
        )]
        
        # Ensure no driver is set
        analyzer.neo4j_driver = None
        
        # Should not raise exception
        analyzer.annotate_graph(pkg, vulns)

    def test_traverse_impact_no_driver(self, analyzer):
        """Test impact traversal without Neo4j driver."""
        analyzer.neo4j_driver = None
        
        result = analyzer.traverse_impact("CVE-2023-1234")
        
        assert result == []

    def test_recommend_remediations_no_vulnerabilities(self, analyzer):
        """Test remediation recommendations with no vulnerabilities."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        
        recs = analyzer.recommend_remediations(pkg, [])
        
        assert recs["vulnerabilities"] == 0
        assert recs["priority"] == "LOW"
        assert "No vulnerabilities found" in recs["actions"][0]

    def test_recommend_remediations_critical_vulnerability(self, analyzer):
        """Test remediation recommendations with critical vulnerability."""
        pkg = Package(name="requests", version="2.28.1", ecosystem="python")
        vulns = [Vulnerability(
            cve_id="CVE-2023-1234",
            severity="CRITICAL",
            description="Test",
            cvss_score=9.5,
            published_date="2023-01-01T00:00:00Z",
            affected_versions=[],
            fixed_versions=[]
        )]
        
        recs = analyzer.recommend_remediations(pkg, vulns)
        
        assert recs["priority"] == "CRITICAL"
        assert "Immediate action required" in recs["actions"]

    # ==================== INTEGRATION TESTS ====================

    def test_full_analysis_workflow(self, analyzer, temp_repo):
        """Test complete analysis workflow."""
        with patch.object(analyzer, 'connect_neo4j', return_value=True):
            with patch.object(analyzer, 'fetch_vulnerabilities_for', return_value=[]):
                with patch.object(analyzer, 'annotate_graph'):
                    with patch.object(analyzer, 'traverse_impact', return_value=[]):
                        with patch.object(analyzer, 'recommend_remediations') as mock_recs:
                            mock_recs.return_value = {
                                "package": "requests",
                                "current_version": "2.28.1",
                                "vulnerabilities": 0,
                                "actions": ["No vulnerabilities found"],
                                "priority": "LOW"
                            }
                            
                            # Test the main workflow
                            manifests = analyzer.load_manifests(str(temp_repo))
                            assert len(manifests) > 0
                            
                            for pkg in manifests:
                                vulns = analyzer.fetch_vulnerabilities_for(pkg)
                                analyzer.annotate_graph(pkg, vulns)
                                impact = analyzer.traverse_impact("test-cve")
                                recs = analyzer.recommend_remediations(pkg, vulns)
                                
                                assert isinstance(recs, dict)
                                assert "package" in recs

    def test_error_handling_in_parsers(self, analyzer):
        """Test error handling in manifest parsers."""
        with tempfile.TemporaryDirectory() as temp_dir:
            repo_path = Path(temp_dir)
            
            # Create file that will cause parsing errors
            (repo_path / "requirements.txt").write_text("invalid\nformat\n==\n")
            
            packages = analyzer.load_manifests(temp_dir)
            
            # Should handle errors gracefully
            assert isinstance(packages, list)

    def test_version_comparison_edge_cases(self, analyzer):
        """Test version comparison edge cases."""
        pkg = Package(name="requests", version="latest", ecosystem="python")
        
        # Test with various version formats
        test_versions = ["1.0.0", "2.0.0", "latest", "dev", "1.0.0-alpha"]
        
        for version in test_versions:
            pkg.version = version
            # Should not raise exceptions
            vulns = analyzer.fetch_vulnerabilities_for(pkg)
            assert isinstance(vulns, list)


if __name__ == "__main__":
    pytest.main([__file__, "-v"]) 